# ЗАДАЧА: Разработка Telegram-бота для продажи n8n workflows

## КОНТЕКСТ ПРОЕКТА

Я разрабатываю **Telegram-бота для автоматизированной продажи n8n workflows** (готовые JSON-конфигурации для автоматизации серверного мониторинга).
Бот должен работать как полноценный интернет-магазин внутри Telegram.

### Бизнес-модель
- **Продукт:** 10 n8n workflows для мониторинга серверов (CPU, RAM, Load Average, Swap, inode, сервисы, логи /var/log, SSH-попытки, Docker)
- **Целевая аудитория:** DevOps-специалисты, владельцы VPS (5-50 серверов), использующие n8n для автоматизации
- **Цена:** 400 за 1 workflow (Early Bird: первые 50 покупателей по 400 → потом 600)
- **Bundle-скидки:** 4 workflows = -19%, 8 workflows = -19%, 10 workflows (ALL) = -20%
- **USP:** Дешевле Zabbix/Prometheus (которые стоят 2500/мес), быстрая настройка (5 минут), уведомления в Telegram

### Ключевые особенности продукта:
1. **Водяные знаки (watermarking):** Каждый проданный JSON-файл содержит уникальную секцию `license` с `purchased_by`, `purchase_date`, `payment_id`, `update_token` (70% файла - metadata в nodes, 30% - секция license)
2. **Защита от утечек:** Если workflow попадёт в GitHub/GitLab, я смогу идентифицировать источник по watermark
3. **Обновления:** Клиенты могут купить апгрейд (v1.2 → v1.3) за 50 через `update_token`

## АРХИТЕКТУРА (ПРИНЯТЫЕ РЕШЕНИЯ)

### 1. Технический стек:
- **Backend:** Python 3.9+ с aiogram 3.x (асинхронный фреймворк для Telegram Bot API)
- **База данных:** Supabase (PostgreSQL-as-a-Service) - 6 таблиц: users, workflows, purchases, workflow_updates, invite_links, settings
- **Платежи:** ЮKassa через Telegram Payments API (комиссия 2.8% + НПД 4%)
- **Хостинг:** VPS Beget (800-900 р/мес в продакшене)
- **Файловая система:** JSON-файлы хранятся на VPS в `/var/www/workflows-shop/workflows/` (оригиналы) и `/var/www/workflows-shop/watermarked/` (временные копии с водяными знаками, удаляются через 24 часа cron-задачей)

### 2. Архитектура бота (классический Telegram Bot, НЕ Mini App):
**Решено использовать классический подход с Inline-кнопками и редактированием сообщений (`edit_text()`)**, а не Mini App, по следующим причинам:
- Быстрая разработка MVP (1-2 недели vs 4-6 недель для Mini App)
- Простота поддержки (только Python, без React/frontend)
- Достаточно для 10 workflows на старте
- Mini App можно добавить позже после валидации спроса (50+ продаж)

### 3. Навигация в боте:
```
/start → Главное меню [inline-кнопки]
   ↓
[Каталог workflows] → Список workflows с фильтрами (Priority 1/2/3)
   ↓
Клик на workflow → Карточка workflow (редактирование того же сообщения через edit_text)
   ↓
[Купить 400] → Telegram Invoice (send_invoice через ЮKassa)
   ↓
Оплата → successful_payment event
   ↓
Бот отправляет JSON-файл с водяным знаком + инвайт в приватный канал
```

**ВАЖНО:** Вся навигация (каталог → карточка → назад) происходит через **редактирование одного сообщения** (`callback.message.edit_text()`), а НЕ через отправку новых сообщений. Новые сообщения создаются только для: Invoice (платежи), файлов после покупки, поддержки.

### 4. Deep Links для Threads:
Для рекламы workflows в Threads используются ссылки вида:
```
https://t.me/MyBot?start=cpu-monitoring
```
При переходе бот парсит параметр `cpu-monitoring` и **сразу показывает карточку** этого workflow (минуя каталог).

### 5. Система водяных знаков:
**В БД хранится только путь к оригинальному файлу** (`/var/www/.../cpu_monitoring.json`).
При покупке:
1. Python-функция `add_watermark_to_workflow()` (в `utils/watermark.py`) читает оригинал
2. Добавляет секцию `license` с данными покупателя
3. Добавляет `notes` в каждую node: `[Licensed to: @username]`
4. Сохраняет копию в `watermarked/` с именем `{user_id}_{timestamp}_{slug}.json`
5. Отправляет эту копию клиенту через `bot.send_document()`
6. Копия автоматически удаляется через 72 часа (cron в 4:00)

## СТРУКТУРА ПРОЕКТА НА VPS

```
/var/www/workflows-shop/
├── bot.py                 # Главный файл (запуск бота 24/7)
├── handlers/              # Обработчики команд
│   ├── start.py           # /start, /help
│   ├── catalog.py        # /catalog, показ workflows
│   ├── payment.py       # successful_payment, покупка
│   ├── admin.py          # /stats, /addworkflow, /ban
│   └── support.py         # /support
├── utils/                  # Вспомогательные функции
│   ├── watermark.py      # add_watermark_to_workflow()
│   ├── encryption.py      # Шифрование payment_id (AES-256)
│   ├── logger.py          # Логирование (loguru)
│   └── filemanager.py     # Работа с файлами
├── database/
│   ├── supabase_client.py # Клиент Supabase
│   └── models.py          # Модели данных
├── keyboards/
│   ├── inline.py          # Inline-кнопки (main_menu, catalog, workflow_card)
│   └── reply.py           # Reply-кнопки
├── middlewares/
│   ├── ratelimit.py       # Rate limiting (10 req/min)
│   └── bancheck.py        # Проверка banned_users
├── workflows/             # JSON-файлы (оригиналы)
│   ├── cpu_monitoring_v1.0.json
│   ├── ram_monitoring_v1.0.json
│   └── ...
├── watermarked/           # Временные копии (удаляются через 24ч)
├── backups/               # Бэкапы (cron 3:00)
├── logs/                  # bot.log, delivery.log, security.log
├── scripts/
│   ├── backup.sh          # Бэкап workflows + БД
│   └── cleanup.sh         # Очистка watermarked/
├── .env                   # BOT_TOKEN, SUPABASE_URL, YUKASSA_TOKEN
├── requirements.txt
└── config.py
```

## СХЕМА БД (SUPABASE)

### Таблица `workflows`:
```sql
CREATE TABLE workflows (
    id SERIAL PRIMARY KEY,
    slug VARCHAR(50) UNIQUE,              -- "cpu-monitoring"
    name VARCHAR(255),                    -- "CPU Monitoring v1.2"
    description TEXT,
    category VARCHAR(50),                 -- "monitoring"
    priority INT,                         -- 1, 2 или 3
    price DECIMAL(10,2),                  -- 400.00
    filepath VARCHAR(500),                -- "/var/www/.../cpu_monitoring.json"
    version VARCHAR(10),                  -- "1.2"
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    downloads INT DEFAULT 0,
    revenue DECIMAL(10,2) DEFAULT 0
);
```

### Таблица `purchases`:
```sql
CREATE TABLE purchases (
    id SERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,              -- Telegram ID
    workflow_id INT REFERENCES workflows(id),
    price DECIMAL(10,2),
    payment_id VARCHAR(255),              -- Зашифрованный ID от ЮKassa
    purchased_at TIMESTAMP DEFAULT NOW(),
    email VARCHAR(255),
    download_count INT DEFAULT 0,
    last_download_at TIMESTAMP,
    ip_address VARCHAR(45)
);
```
### Остальные таблицы:
- `users` (telegram_id, username, registered_at, total_spent, referral_source)
- `workflow_updates` (workflow_id, version, changelog, update_price, released_at)
- `invite_links` (workflow_id, invite_link, expires_at)
- `settings` (key, value) - для Early Bird счётчика, конфигов
- `banned_users` (telegram_id, reason, banned_at, banned_by)
- `delivery_logs` (user_id, workflow_id, status, error_message, delivered_at)

## КЛЮЧЕВЫЕ ФАЙЛЫ И ФУНКЦИИ

### 1. `handlers/payment.py` - Обработка покупок:
```python
@router.message(F.successful_payment)
async def handle_successful_payment(message: Message, bot: Bot):
    # 1. Парсим payload
    payment = message.successful_payment
    payload = payment.invoice_payload  # "workflow_cpu-monitoring_123456789"
    
    # 2. Получаем workflow из БД
    workflow = supabase.table("workflows").select("*").eq("slug", slug).execute()
    
    # 3. Добавляем водяной знак
    watermarked_filepath = add_watermark_to_workflow(
        original_filepath=workflow["filepath"],
        user_id=message.from_user.id,
        username=message.from_user.username,
        payment_id=payment.telegram_payment_charge_id,
        workflow_version=workflow["version"]
    )
    
    # 4. Отправляем файл
    await bot.send_document(chat_id=message.chat.id, document=open(watermarked_filepath, 'rb'))
    
    # 5. Логируем
    log_delivery(user_id, workflow_id, "success")
```

### 2. `utils/watermark.py` - Водяные знаки:
```python
def add_watermark_to_workflow(original_filepath, user_id, username, payment_id, workflow_version):
    # Читаем JSON → добавляем license + notes в nodes → сохраняем в watermarked/
    with open(original_filepath, 'r') as f:
        workflow_data = json.load(f)
    
    workflow_data['license'] = {
        "purchased_by": f"TGUSER{user_id}",
        "purchase_date": datetime.now().isoformat(),
        "payment_id": payment_id,
        "update_token": uuid.uuid4().hex
    }
    
    for node in workflow_data['nodes']:
        node['notes'] += f"\n\n[Licensed to: @{username}]"
    
    watermarked_path = f"/var/www/.../watermarked/{user_id}_{timestamp}_{slug}.json"
    with open(watermarked_path, 'w') as f:
        json.dump(workflow_data, f)
    
    return watermarked_path
```

### 3. `keyboards/inline.py` - Клавиатуры:
```python
def workflow_card_keyboard(slug: str, price: int):
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"? Купить {price}?", callback_data=f"buy:{slug}")],
        [InlineKeyboardButton(text="? Подробнее", callback_data=f"details:{slug}")],
        [InlineKeyboardButton(text="? Видео-демо", url=f"https://youtube.com/...")],
        [InlineKeyboardButton(text="? Назад в каталог", callback_data="catalog")]
    ])
```

## БЕЗОПАСНОСТЬ И BEST PRACTICES

1. **Rate Limiting:** 10 запросов/минуту через middleware (защита от флуда)
2. **Шифрование payment_id:** AES-256 через `cryptography.fernet`
3. **Права доступа к файлам:** `.env` - 600, workflows/ - 644, backups/ - 700
4. **SSH:** ключи вместо паролей, порт 2222 вместо 22
5. **Firewall:** UFW блокирует всё кроме SSH/HTTP/HTTPS
6. **Бэкапы:** Автоматические (cron 3:00) с ротацией 60 дней
7. **Логирование:** `loguru` с уровнями INFO/ERROR/WARNING, ротация 1 неделя
8. **SQL Injection:** Используем Supabase SDK (параметризованные запросы)

## АВТОМАТИЗАЦИЯ (CRON)

```bash
# Бэкап workflows + БД каждую ночь в 3:00
0 3 * * * /var/www/workflows-shop/scripts/backup.sh

# Очистка watermarked/ каждые 3 дня в 4:00
0 4 * * * /var/www/workflows-shop/scripts/cleanup.sh
```

## АДМИНКА

Команды для управления (доступны только ADMIN_IDS):
- `/stats` - статистика (пользователи, продажи, выручка, топ-3 workflows)
- `/addworkflow` - добавление нового workflow (FSM state machine)
- `/changeprice slug 600` - изменение цены
- `/ban telegram_id причина` - бан пользователя
- `/userhistory telegram_id` - история покупок
- `/sendfile telegram_id slug` - повторная отправка файла
- `/backupnow` - ручной бэкап

## NEXT STEPS (ЧТО НУЖНО СДЕЛАТЬ)

Я готов перейти к практической реализации.
В файле `Продажа-n8n-workflow.docx` (адрес укажу чуть позже) есть ВСЯ детальная спецификация проекта (100+ страниц), включая:
- Раздел 1: Описание продукта и бизнес-логика
- Раздел 2: Интеграция с ЮKassa (send_invoice, webhook)
- Раздел 3: Технический дизайн (структура проекта)
- Раздел 4: Безопасность (watermarking, шифрование, backups)
- Раздел 5: UX/UI (сценарии использования, тексты сообщений)
- Раздел 6: Админка (статистика, управление workflows)

## МОЯ ЦЕЛЬ В ЭТОЙ СЕССИИ:
**Написать конкретный Python-код для реализации бота**, начиная с базовой структуры проекта.
Мне нужна помощь с:
1. Инициализацией проекта (`bot.py`, структура папок, `requirements.txt`)
2. Настройкой Supabase (создание таблиц, подключение)
3. Реализацией основных handlers (start, catalog, payment)
4. Интеграцией с ЮKassa через Telegram Payments API
5. Функцией водяных знаков (`add_watermark_to_workflow`)
6. Middleware (rate limiting, ban check)
7. Админ-командами

**Пожалуйста, помоги мне написать ГОТОВЫЙ К ЗАПУСКУ код**, учитывая все архитектурные решения из этого контекста.
Используй современные best practices Python/aiogram 3.x/async programming.

Путь к файлу `Продажа-n8n-workflow.docx` укажу в следующем сообщении.

КРИТИЧЕСКИ ВАЖНО!!! 
Не "вываливай" весь код сразу.
ОБЩАЯ СТРУКТУРА ПЛАНА написана ниже.
Она разбита на небольшие этапы.
Это необходимо для комфортной и неспешной реализации и создания бота с моей стороны.
Давай двигаться поэтапно.
Перед началом разработки ожидай мою команду.

===============================================================================

ОБЩАЯ СТРУКТУРА ПЛАНА
Разобью разработку на 9 основных этапов + 1 финальный. Каждый этап — это 30-90 минут работы с конкретным результатом.

ЭТАП 0: Подготовка окружения
Цель: Создать базовую структуру проекта и настроить окружение
Что сделаем:
Структура папок проекта
requirements.txt с зависимостями
.env.example шаблон
config.py для настроек
.gitignore
Базовый README.md
Результат: Готовая структура для старта разработки

ЭТАП 1: База данных (Supabase)
Цель: Создать схему БД и подключение
Что сделаем:
SQL-скрипты для создания 6 таблиц:
users
workflows
purchases
workflow_updates
invite_links
settings
database/supabase_client.py — клиент для подключения
database/models.py — модели данных (dataclasses)
Тестовое подключение
Результат: Работающая БД с тестовыми данными

ЭТАП 2: Базовый бот (запуск и команды)
Цель: Запустить бота с основными командами
Что сделаем:
bot.py — главный файл запуска
handlers/start.py — /start, /help
keyboards/inline.py — базовые кнопки
Регистрация пользователей в БД
Простое меню
Результат: Бот отвечает на /start и регистрирует пользователей

ЭТАП 3: Каталог workflows
Цель: Показ списка workflows с навигацией
Что сделаем:
handlers/catalog.py — каталог
Inline-кнопки для навигации (каталог → карточка → назад)
Карточка workflow с описанием
Deep Links для Threads (?start=wf_cpu-monitoring)
Фильтрация по Priority (1, 2, 3)
Результат: Пользователь может просматривать каталог

ЭТАП 4: Интеграция с ЮKass
Цель: Принимать платежи
Что сделаем:
handlers/payment.py:
Отправка Invoice (sendInvoice)
Обработка pre_checkout_query
Обработка successful_payment
Сохранение покупки в БД
Логика Early Bird (счетчик первых 50 покупателей)
Автопереход на Фазу 2 (600?)
Результат: Бот принимает платежи, сохраняет в БД

ЭТАП 5: Водяные знаки и доставка
Цель: Генерация персонализированных файлов
Что сделаем:
utils/watermark.py:
Функция add_watermark_to_workflow()
Добавление секции _license в JSON
Добавление notes в nodes
Генерация update_token
utils/filemanager.py — работа с файлами
Отправка файла через bot.send_document()
Логирование доставки
Результат: Клиент получает файл с водяным знаком после оплаты

ЭТАП 6: Приватный канал (инвайты)
Цель: Автоматические приглашения
Что сделаем:
utils/invite_links.py:
Генерация инвайт-ссылок (48 часов)
Хранение в БД
Отправка клиенту после покупки
Настройка приватного канала (инструкции)
Welcome-сообщение в канале
Результат: Покупатель автоматически получает инвайт в канал

ЭТАП 7: Middleware и защита
Цель: Безопасность бота
Что сделаем:
middlewares/ratelimit.py — 10 запросов/минуту
middlewares/bancheck.py — проверка бана
utils/encryption.py — шифрование payment_id (AES-256)
utils/logger.py — логирование с loguru
Таблица banned_users
Результат: Защита от флуда и спама

ЭТАП 8: Админ-панель
Цель: Управление ботом
Что сделаем:
handlers/admin.py:
/stats — статистика (продажи, выручка, топ workflows)
/addworkflow — добавление нового workflow (FSM)
/changeprice — изменение цены
/ban / /unban — управление пользователями
/userhistory — история покупок клиента
/sendfile — повторная отправка файла
/broadcast — рассылка всем клиентам
Проверка ADMIN_IDS из .env
Результат: Полный контроль над ботом

ЭТАП 9: Автоматизация (cron, systemd)
Цель: Автозапуск и обслуживание
Что сделаем:
scripts/backup.sh — бэкап workflows + БД
scripts/cleanup.sh — очистка watermarked/
workflows_bot.service — systemd unit
Инструкции по деплою на Beget VPS
Настройка cron-задач:
Бэкап: каждое воскресенье 03:00
Очистка: каждый день 04:00
Результат: Бот работает 24/7, автоматические бэкапы

ЭТАП 10: Финальное тестирование и документация
Цель: Готовность к запуску
Что сделаем:
Тестирование всех сценариев:
Регистрация → каталог → покупка → файл → инвайт
Deep Links
Early Bird переход на Фазу 2
Админ-команды
Документация:
DEPLOY.md — инструкция деплоя
ADMIN_GUIDE.md — руководство администратора
TROUBLESHOOTING.md — решение проблем
Чек-лист запуска
Результат: Полностью рабочий бот, готовый к продакшену


========================================================================
Get content by
python3 -c "with open('my_n8n/python_bot.txt', 'r', encoding='cp1251') as f: print(f.read())"






